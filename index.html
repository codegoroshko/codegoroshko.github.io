<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>–ö–æ–¥–µ–≥–æ—Ä–æ—à–∫–æ - –ê–ª–≥–æ—Ä–∏—Ç–º—ñ—á–Ω–∞ –†–ü–ì</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" 
          integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" 
          crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overscroll-behavior: none;
            -webkit-font-smoothing: antialiased;
        }
        
        /* –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –¥–ª—è touch */
        .drag-placeholder {
            height: 50px;
            background: rgba(139, 92, 246, 0.2);
            border: 2px dashed rgb(139, 92, 246);
            border-radius: 0.5rem;
            margin-bottom: -1px;
            pointer-events: none;
        }

        .dragging {
            opacity: 0.5;
            transform: scale(1.05);
            transition: none !important;
        }

        .program-block, .block {
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            will-change: transform;
        }

        .program-block i, .block i {
            pointer-events: none;
        }

        /* –ü–æ–∫—Ä–∞—â–µ–Ω—ñ –∞–Ω—ñ–º–∞—Ü—ñ—ó (< 300ms) */
        .fade-in {
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .level-complete {
            animation: celebrate 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes celebrate {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(-5deg); }
            75% { transform: scale(1.1) rotate(5deg); }
        }

        /* –ü—É–ª—å—Å –¥–ª—è –ø—ñ–¥–∫–∞–∑–æ–∫ */
        .pulse-hint {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* –ê–¥–∞–ø—Ç–∏–≤–Ω–∞ —Å—ñ—Ç–∫–∞ */
        .grid {
            max-width: min(90vw, 500px);
            aspect-ratio: 1;
        }

        .cell {
            min-height: 0;
            font-size: clamp(1.5rem, 4vw, 2rem);
        }

        /* –ö–Ω–æ–ø–∫–∏ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö (–º—ñ–Ω—ñ–º—É–º 44x44px) */
        button {
            min-height: 44px;
            min-width: 44px;
        }

        /* –ü–ª–∞–≤–Ω–∏–π —Å–∫—Ä–æ–ª */
        .program-area {
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }

        /* –£—Å–ø—ñ—Ö –∞–Ω—ñ–º–∞—Ü—ñ—è */
        @keyframes successGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(34, 197, 94, 0.5); }
            50% { box-shadow: 0 0 40px rgba(34, 197, 94, 0.8); }
        }

        .success-glow {
            animation: successGlow 1s ease-in-out;
        }

        /* –ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è –¥–ª—è iOS */
        input[type="number"] {
            -webkit-appearance: none;
            appearance: none;
        }

        /* –Ü–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ä—ñ–≤–Ω—è –ø—Ä–æ–≥—Ä–µ—Å—É */
        .level-progress {
            transition: width 0.3s ease-out;
        }

        /* Haptic feedback –µ–º—É–ª—è—Ü—ñ—è */
        .haptic-light {
            transition: transform 0.05s;
        }

        .haptic-light:active {
            transform: scale(0.98);
        }

        /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ –≤—ñ–¥—Å—Ç—É–ø–∏ */
        @media (max-width: 640px) {
            .container {
                padding: 1rem;
            }
            
            .block, .program-block {
                font-size: 0.875rem;
            }
        }
        
        /* –ù–û–í–ï: –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–µ —Ä–æ–∑—Ç–∞—à—É–≤–∞–Ω–Ω—è –¢–Ü–õ–¨–ö–ò –Ω–∞ –¥—É–∂–µ –º–∞–ª–µ–Ω—å–∫–∏—Ö –µ–∫—Ä–∞–Ω–∞—Ö */
        @media (max-width: 480px) {
            .programming-wrapper {
                display: flex !important;
                flex-direction: row !important;
                gap: 0.5rem !important;
            }
            
            .blocks-area {
                width: 40% !important;
            }
            
            .program-container {
                width: 60% !important;
            }
        }

        /* Landscape –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—è –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö */
        @media (max-width: 768px) and (orientation: landscape) {
            .game-area {
                flex-direction: row !important;
            }
            
            .grid {
                max-width: 45vh;
            }
        }

        /* –¢–µ–º–Ω–∞ —Ç–µ–º–∞ –¥–ª—è –∑–º–µ–Ω—à–µ–Ω–Ω—è –≤—Ç–æ–º–∏ –æ—á–µ–π */
        @media (prefers-color-scheme: dark) {
            body {
                filter: brightness(0.95);
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-500 to-purple-600 p-2 md:p-4 min-h-screen">

    <!-- –ú–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ -->
    <div id="modal" class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4 hidden">
        <div id="modalContent" class="bg-white rounded-2xl shadow-2xl w-full max-w-md transform transition-all scale-95 opacity-0">
            <div class="p-6 text-center">
                <div id="modalIcon" class="w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4 text-4xl"></div>
                <h3 id="modalTitle" class="text-2xl font-bold text-gray-800 mb-2"></h3>
                <p id="modalMessage" class="text-base text-gray-600 mb-6 whitespace-pre-line"></p>
                <div id="modalButtons" class="flex gap-3 justify-center flex-wrap"></div>
            </div>
        </div>
    </div>

    <!-- –ü—ñ–¥–∫–∞–∑–∫–∏ –¥–ª—è –ø–µ—Ä—à–æ–≥–æ —Ä—ñ–≤–Ω—è -->
    <div id="tutorialOverlay" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-40 hidden items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-2xl max-w-md p-6 text-center">
            <div class="text-5xl mb-4">üëÜ</div>
            <h3 class="text-xl font-bold text-gray-800 mb-3">–Ø–∫ –≥—Ä–∞—Ç–∏?</h3>
            <div class="text-left text-gray-700 space-y-2 mb-6 text-sm">
                <p><strong>–ö–æ–º–ø'—é—Ç–µ—Ä:</strong> –ü–µ—Ä–µ—Ç—è–≥—É–π—Ç–µ –∫–æ–º–∞–Ω–¥–∏ –º–∏—à–µ—é</p>
                <p><strong>–ú–æ–±—ñ–ª—å–Ω–∏–π:</strong> –¢–æ—Ä–∫–∞–π—Ç–µ—Å—å —Ç–∞ –ø–µ—Ä–µ—Ç—è–≥—É–π—Ç–µ –ø–∞–ª—å—Ü–µ–º</p>
                <p><strong>–®–≤–∏–¥–∫–æ:</strong> –ü—Ä–æ—Å—Ç–æ –∫–ª–∞—Ü–∞–π—Ç–µ –ø–æ –∫–æ–º–∞–Ω–¥—ñ</p>
                <p class="text-indigo-600 mt-3">üí° –ö–æ–∂–µ–Ω –∫—Ä–æ–∫ –∑–∞–±–∏—Ä–∞—î 1 –°–∏–ª—É!</p>
            </div>
            <button id="closeTutorial" class="w-full py-3 px-6 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-600 transition haptic-light">
                –ó—Ä–æ–∑—É–º—ñ–ª–æ!
            </button>
        </div>
    </div>

    <div class="container max-w-7xl mx-auto bg-white rounded-2xl p-3 md:p-6 shadow-2xl">
        
        <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ -->
        <h1 class="text-center text-xl md:text-3xl font-bold text-indigo-600 mb-3 md:mb-4">
            <i class="fa-solid fa-dragon mr-2"></i> –ö–æ–¥–µ–≥–æ—Ä–æ—à–∫–æ
        </h1>
        
        <!-- –ü—Ä–æ–≥—Ä–µ—Å-–±–∞—Ä —Ä—ñ–≤–Ω—è -->
        <div class="w-full bg-gray-200 rounded-full h-2 mb-4">
            <div id="levelProgressBar" class="level-progress bg-gradient-to-r from-indigo-500 to-purple-500 h-2 rounded-full" style="width: 10%"></div>
        </div>

        <!-- –í–∏–±—ñ—Ä —Ä—ñ–≤–Ω—è –∑ –ø—ñ–¥–∫–∞–∑–∫–∞–º–∏ -->
        <div class="level-selector mb-4 text-center">
            <div class="inline-flex items-center gap-2 md:gap-3 bg-gray-100 p-2 md:p-3 rounded-lg">
                <button id="prevLevel" class="haptic-light px-3 md:px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition disabled:opacity-50 disabled:cursor-not-allowed">
                    <i class="fa-solid fa-chevron-left"></i>
                </button>
                <div class="text-base md:text-lg font-bold">
                    –†—ñ–≤–µ–Ω—å <span id="currentLevel">1</span> / 10
                </div>
                <button id="nextLevel" class="haptic-light px-3 md:px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition disabled:opacity-50 disabled:cursor-not-allowed">
                    <i class="fa-solid fa-chevron-right"></i>
                </button>
                <button id="showTutorial" class="haptic-light px-3 md:px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition" title="–ü–æ–∫–∞–∑–∞—Ç–∏ –ø—ñ–¥–∫–∞–∑–∫—É">
                    <i class="fa-solid fa-question"></i>
                </button>
            </div>
        </div>

        <!-- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (–∞–¥–∞–ø—Ç–∏–≤–Ω–∞) -->
        <div class="flex flex-wrap gap-2 md:gap-4 justify-center mb-4 text-sm md:text-base">
            <div class="stat bg-white py-2 px-3 md:px-5 rounded-lg border-2 border-indigo-500 font-semibold">
                <i class="fa-solid fa-gavel text-gray-600"></i> <span id="weapon">0</span>
            </div>
            <div class="stat bg-white py-2 px-3 md:px-5 rounded-lg border-2 border-red-500 font-semibold">
                <i class="fa-solid fa-heart text-red-500"></i> <span id="strength">15</span>
            </div>
            <div class="stat bg-white py-2 px-3 md:px-5 rounded-lg border-2 border-blue-500 font-semibold text-xs md:text-base">
                <i class="fa-solid fa-location-dot text-blue-500"></i> <span id="position">(0, 0)</span>
            </div>
        </div>

        <div class="game-area flex flex-col lg:flex-row gap-4 md:gap-6 mb-4 md:mb-6">
            
            <!-- –°—ñ—Ç–∫–∞ –≥—Ä–∏ -->
            <div class="grid-container flex-shrink-0 mx-auto lg:mx-0">
                <div class="grid gap-0.5 bg-gray-300 p-0.5 rounded-lg mb-3 mx-auto"></div>
                <div class="controls flex gap-2 md:gap-3 flex-wrap justify-center">
                    <button class="run-btn haptic-light flex items-center justify-center py-2.5 md:py-3 px-4 md:px-6 text-sm md:text-base font-semibold rounded-lg shadow-md transition-all bg-green-500 text-white hover:bg-green-600 active:scale-95">
                        <i class="fa-solid fa-play mr-2"></i> –ó–∞–ø—É—Å—Ç–∏—Ç–∏
                    </button>
                    <button class="reset-btn haptic-light flex items-center justify-center py-2.5 md:py-3 px-4 md:px-6 text-sm md:text-base font-semibold rounded-lg shadow-md transition-all bg-yellow-400 text-gray-800 hover:bg-yellow-500 active:scale-95">
                        <i class="fa-solid fa-arrows-rotate mr-2"></i> –°–∫–∏–Ω—É—Ç–∏
                    </button>
                    <button class="clear-btn haptic-light flex items-center justify-center py-2.5 md:py-3 px-4 md:px-6 text-sm md:text-base font-semibold rounded-lg shadow-md transition-all bg-red-500 text-white hover:bg-red-600 active:scale-95">
                        <i class="fa-solid fa-trash mr-2"></i> –û—á–∏—Å—Ç–∏—Ç–∏
                    </button>
                </div>
                <div id="levelInfo" class="info mt-3 p-3 bg-blue-50 border-l-4 border-blue-400 text-blue-700 rounded-md text-xs md:text-sm"></div>
                
                <!-- –õ—ñ—á–∏–ª—å–Ω–∏–∫ –∫—Ä–æ–∫—ñ–≤ -->
                <div id="stepCounter" class="mt-3 p-2 bg-purple-50 border-l-4 border-purple-400 text-purple-700 rounded-md text-xs md:text-sm text-center font-semibold hidden">
                    –ö—Ä–æ–∫—ñ–≤ —É –ø—Ä–æ–≥—Ä–∞–º—ñ: <span id="stepCount">0</span>
                </div>
            </div>

            <!-- –ü—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è -->
            <div class="programming-wrapper flex flex-col sm:flex-row flex-1 gap-3 md:gap-4">
                
                <!-- –ü–∞–ª—ñ—Ç—Ä–∞ –∫–æ–º–∞–Ω–¥ -->
                <div class="blocks-area w-full sm:w-[35%] bg-gradient-to-br from-gray-50 to-gray-100 p-3 md:p-4 rounded-lg border-2 border-gray-200">
                    <div class="blocks-title text-base md:text-lg font-bold mb-3 text-gray-700 flex items-center justify-between">
                        <span><i class="fa-solid fa-box-archive mr-2"></i>–ö–æ–º–∞–Ω–¥–∏</span>
                        <span class="text-xs text-gray-500 hidden sm:inline">–¢–æ—Ä–∫–∞–π—Å—è</span>
                    </div>
                    <div class="flex flex-col gap-2">
                        <div class="block haptic-light" draggable="true" data-command="up">
                            <i class="fa-solid fa-arrow-up w-5"></i> –í–≥–æ—Ä—É
                        </div>
                        <div class="block haptic-light" draggable="true" data-command="down">
                            <i class="fa-solid fa-arrow-down w-5"></i> –í–Ω–∏–∑
                        </div>
                        <div class="block haptic-light" draggable="true" data-command="left">
                            <i class="fa-solid fa-arrow-left w-5"></i> –õ—ñ–≤–æ—Ä—É—á
                        </div>
                        <div class="block haptic-light" draggable="true" data-command="right">
                            <i class="fa-solid fa-arrow-right w-5"></i> –ü—Ä–∞–≤–æ—Ä—É—á
                        </div>
                        
                        <div id="loopsSection" class="hidden">
                            <div class="w-full mt-2 mb-1 font-bold text-gray-600 text-xs md:text-sm">
                                <i class="fa-solid fa-arrows-spin mr-2"></i>–¶–∏–∫–ª–∏:
                            </div>
                            <div class="block loop haptic-light" draggable="true" data-command="loop">
                                <i class="fa-solid fa-repeat w-5"></i> –ü–æ–≤—Ç–æ—Ä–∏—Ç–∏
                            </div>
                        </div>
                    </div>
                </div>
            
                <!-- –ü—Ä–æ–≥—Ä–∞–º–∞ -->
                <div class="program-container flex flex-col w-full sm:w-[65%]">
                    <div class="blocks-title text-base md:text-lg font-bold mb-3 text-gray-700 flex items-center justify-between">
                        <span><i class="fa-solid fa-wrench mr-2"></i>–ü—Ä–æ–≥—Ä–∞–º–∞</span>
                        <span id="programCount" class="text-xs text-gray-500">0 –±–ª–æ–∫—ñ–≤</span>
                    </div>
                    <div id="programArea" class="program-area flex-1 bg-gradient-to-br from-gray-100 to-gray-50 p-3 md:p-4 rounded-lg border-2 border-dashed border-gray-400 min-h-[200px] max-h-[400px] overflow-y-auto"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'inter': ['Inter', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'sans-serif'],
                    },
                },
            },
        }
    </script>
    
    <script>
        // ====================================
        // –ö–û–ù–§–Ü–ì–£–†–ê–¶–Ü–Ø
        // ====================================

        const CONFIG = {
            GRID_SIZE: 8,
            MAX_LOOP_COUNT: 5, // –ó–º–µ–Ω—à–µ–Ω–æ –¥–ª—è –±–∞–ª–∞–Ω—Å—É
            MIN_LOOP_COUNT: 2,
            ANIMATION_DELAY: 350, // –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–æ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö
            MAX_EXECUTION_STEPS: 500, // –û–±–º–µ–∂–µ–Ω–Ω—è –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –∑–∞–≤–∏—Å–∞–Ω—å
            TOTAL_LEVELS: 10,
            TOUCH_HOLD_DELAY: 150, // –ó–∞—Ç—Ä–∏–º–∫–∞ –¥–ª—è –≤—ñ–¥—Ä—ñ–∑–Ω–µ–Ω–Ω—è tap –≤—ñ–¥ drag
            HAPTIC_ENABLED: 'vibrate' in navigator // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ –≤—ñ–±—Ä–∞—Ü—ñ—ó
        };

        // ====================================
        // –ó–ë–ê–õ–ê–ù–°–û–í–ê–ù–Ü –†–Ü–í–ù–Ü
        // ====================================

        const LEVELS = {
            1: {
                name: "üåü –ü–µ—Ä—à—ñ –∫—Ä–æ–∫–∏",
                description: "–ù–∞–≤—á—ñ—Ç—å—Å—è —Ä—É—Ö–∞—Ç–∏—Å—å! –ü—Ä–æ—Å—Ç–æ –π–¥—ñ—Ç—å –ø—Ä–∞–≤–æ—Ä—É—á –¥–æ –º–æ–Ω—Å—Ç—Ä–∞.",
                gridSize: 6, // –ú–µ–Ω—à–∞ —Å—ñ—Ç–∫–∞ –¥–ª—è –ø–æ—á–∞—Ç–∫—É
                startPos: { x: 0, y: 0 },
                finishPos: { x: 3, y: 0 },
                startingStrength: 15,
                startingWeapon: 8, // –î–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–ª—è –ø–µ—Ä–µ–º–æ–≥–∏
                monsterStrength: 10,
                monsterDefense: 5,
                items: [],
                obstacles: [],
                allowLoops: false,
                hint: "üí° –¢–æ—Ä–∫–Ω—ñ—Ç—å—Å—è –∫–æ–º–∞–Ω–¥–∏ '–ü—Ä–∞–≤–æ—Ä—É—á' 3 —Ä–∞–∑–∏ –∞–±–æ –ø–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å —ó—ó",
                difficulty: "–õ–µ–≥–∫–æ",
                optimalSteps: 3
            },
            2: {
                name: "‚ÜóÔ∏è –î—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–∏–π —à–ª—è—Ö",
                description: "–†—É—Ö–∞–π—Ç–µ—Å—è –ø–æ –¥—ñ–∞–≥–æ–Ω–∞–ª—ñ. –ó–±–∏—Ä–∞–π—Ç–µ —Å–∏–ª—É –Ω–∞ —à–ª—è—Ö—É!",
                gridSize: 6,
                startPos: { x: 0, y: 0 },
                finishPos: { x: 2, y: 2 },
                startingStrength: 15,
                startingWeapon: 5,
                monsterStrength: 10,
                monsterDefense: 4,
                items: [
                    { x: 1, y: 1, type: 'strength', value: 5 }
                ],
                obstacles: [],
                allowLoops: false,
                hint: "üí° –ß–µ—Ä–≥—É–π—Ç–µ '–ü—Ä–∞–≤–æ—Ä—É—á' —ñ '–í–Ω–∏–∑'. –ó–±–∏—Ä–∞–π—Ç–µ –±–æ–Ω—É—Å–∏!",
                difficulty: "–õ–µ–≥–∫–æ",
                optimalSteps: 4
            },
            3: {
                name: "‚ö° –ó–±—ñ—Ä —Ä–µ—Å—É—Ä—Å—ñ–≤",
                description: "–ó–±–µ—Ä—ñ—Ç—å –í–°–Ü –±–æ–Ω—É—Å–∏, —â–æ–± –ø–µ—Ä–µ–º–æ–≥—Ç–∏!",
                gridSize: 7,
                startPos: { x: 0, y: 0 },
                finishPos: { x: 4, y: 0 },
                startingStrength: 12,
                startingWeapon: 2,
                monsterStrength: 15,
                monsterDefense: 5,
                items: [
                    { x: 1, y: 0, type: 'strength', value: 8 },
                    { x: 2, y: 0, type: 'weapon', value: 4 },
                    { x: 3, y: 0, type: 'strength', value: 5 }
                ],
                obstacles: [],
                allowLoops: false,
                hint: "üí° –ë–µ–∑ —Ä–µ—Å—É—Ä—Å—ñ–≤ –Ω–µ –ø–µ—Ä–µ–º–æ–∂–µ—Ç–µ! –ü–ª–∞–Ω—É–π—Ç–µ –∫—Ä–æ–∫–∏.",
                difficulty: "–õ–µ–≥–∫–æ",
                optimalSteps: 4
            },
            4: {
                name: "üó°Ô∏è –û–∑–±—Ä–æ—î–Ω–Ω—è",
                description: "–ó–±–µ—Ä—ñ—Ç—å –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –∑–±—Ä–æ—ó. –ú–æ–Ω—Å—Ç—Ä –¥–æ–±—Ä–µ –∑–∞—Ö–∏—â–µ–Ω–∏–π!",
                gridSize: 7,
                startPos: { x: 0, y: 0 },
                finishPos: { x: 3, y: 3 },
                startingStrength: 18,
                startingWeapon: 0,
                monsterStrength: 15,
                monsterDefense: 6,
                items: [
                    { x: 1, y: 1, type: 'weapon', value: 3 },
                    { x: 2, y: 2, type: 'weapon', value: 4 },
                    { x: 3, y: 2, type: 'strength', value: 5 }
                ],
                obstacles: [],
                allowLoops: false,
                hint: "üí° –ó–±—Ä–æ—è >= –ó–∞—Ö–∏—Å—Ç –º–æ–Ω—Å—Ç—Ä–∞! –ó–±–µ—Ä—ñ—Ç—å –æ–±–∏–¥–≤–∞ –±–æ–Ω—É—Å–∏ –∑–±—Ä–æ—ó.",
                difficulty: "–°–µ—Ä–µ–¥–Ω—å–æ",
                optimalSteps: 6
            },
            5: {
                name: "üå≥ –ü–µ—Ä–µ—à–∫–æ–¥–∏",
                description: "–î–µ—Ä–µ–≤–æ –±–ª–æ–∫—É—î —à–ª—è—Ö. –ó–Ω–∞–π–¥—ñ—Ç—å –æ–±—Ö—ñ–¥!",
                gridSize: 7,
                startPos: { x: 0, y: 0 },
                finishPos: { x: 4, y: 0 },
                startingStrength: 20,
                startingWeapon: 5,
                monsterStrength: 12,
                monsterDefense: 4,
                items: [
                    { x: 2, y: 1, type: 'strength', value: 5 }
                ],
                obstacles: [
                    { x: 2, y: 0, type: 'tree' }
                ],
                allowLoops: false,
                hint: "üí° –û–±—ñ–π–¥—ñ—Ç—å –¥–µ—Ä–µ–≤–æ –∑–≤–µ—Ä—Ö—É –∞–±–æ –∑–Ω–∏–∑—É. –ï–∫–æ–Ω–æ–º—Ç–µ –∫—Ä–æ–∫–∏!",
                difficulty: "–°–µ—Ä–µ–¥–Ω—å–æ",
                optimalSteps: 6
            },
            6: {
                name: "ü™® –õ–∞–±—ñ—Ä–∏–Ω—Ç",
                description: "–°–∫–ª–∞–¥–Ω–∏–π —à–ª—è—Ö —á–µ—Ä–µ–∑ –∫–∞–º—ñ–Ω–Ω—è —Ç–∞ –¥–µ—Ä–µ–≤–∞!",
                gridSize: 8,
                startPos: { x: 0, y: 0 },
                finishPos: { x: 5, y: 3 },
                startingStrength: 25,
                startingWeapon: 2,
                monsterStrength: 18,
                monsterDefense: 5,
                items: [
                    { x: 1, y: 1, type: 'strength', value: 8 },
                    { x: 3, y: 2, type: 'weapon', value: 4 },
                    { x: 4, y: 3, type: 'strength', value: 5 }
                ],
                obstacles: [
                    { x: 1, y: 0, type: 'rock' },
                    { x: 2, y: 1, type: 'tree' },
                    { x: 3, y: 3, type: 'rock' }
                ],
                allowLoops: false,
                hint: "üí° –®—É–∫–∞–π—Ç–µ –Ω–∞–π–∫–æ—Ä–æ—Ç—à–∏–π —à–ª—è—Ö –º—ñ–∂ –ø–µ—Ä–µ—à–∫–æ–¥–∞–º–∏.",
                difficulty: "–°–µ—Ä–µ–¥–Ω—å–æ",
                optimalSteps: 10
            },
            7: {
                name: "üîÑ –¶–∏–∫–ª–∏",
                description: "–í—ñ–¥–∫—Ä–∏—Ç–æ —Ü–∏–∫–ª–∏! –û–ø—Ç–∏–º—ñ–∑—É–π—Ç–µ –∫–æ–¥.",
                gridSize: 8,
                startPos: { x: 0, y: 0 },
                finishPos: { x: 5, y: 0 },
                startingStrength: 18,
                startingWeapon: 5,
                monsterStrength: 12,
                monsterDefense: 4,
                items: [
                    { x: 2, y: 0, type: 'strength', value: 5 },
                    { x: 4, y: 0, type: 'strength', value: 5 }
                ],
                obstacles: [],
                allowLoops: true,
                hint: "üí° –ó–∞–º—ñ—Å—Ç—å 5 –±–ª–æ–∫—ñ–≤ '–ü—Ä–∞–≤–æ—Ä—É—á' ‚Üí —Ü–∏–∫–ª '–ü–æ–≤—Ç–æ—Ä–∏—Ç–∏ 5 —Ä–∞–∑—ñ–≤'!",
                difficulty: "–°–µ—Ä–µ–¥–Ω—å–æ",
                optimalSteps: 5
            },
            8: {
                name: "üéØ –ú–∞–π—Å—Ç–µ—Ä —Ü–∏–∫–ª—ñ–≤",
                description: "–í–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ —Ü–∏–∫–ª–∏ –¥–ª—è –æ–±—Ö–æ–¥—É –ø–µ—Ä–µ—à–∫–æ–¥!",
                gridSize: 8,
                startPos: { x: 0, y: 0 },
                finishPos: { x: 4, y: 4 },
                startingStrength: 28,
                startingWeapon: 1,
                monsterStrength: 20,
                monsterDefense: 5,
                items: [
                    { x: 2, y: 2, type: 'strength', value: 8 },
                    { x: 3, y: 3, type: 'weapon', value: 5 },
                    { x: 4, y: 3, type: 'strength', value: 5 }
                ],
                obstacles: [
                    { x: 1, y: 1, type: 'rock' },
                    { x: 2, y: 3, type: 'tree' }
                ],
                allowLoops: true,
                hint: "üí° –ö–æ–º–±—ñ–Ω—É–π—Ç–µ —Ü–∏–∫–ª–∏ –∑ –æ–∫—Ä–µ–º–∏–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏.",
                difficulty: "–°–∫–ª–∞–¥–Ω–æ",
                optimalSteps: 8
            },
            9: {
                name: "üèîÔ∏è –í–µ–ª–∏–∫–µ –≤–∏–ø—Ä–æ–±—É–≤–∞–Ω–Ω—è",
                description: "–î–æ–≤–≥–∏–π —à–ª—è—Ö. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ –≤—Å—ñ –Ω–∞–≤–∏—á–∫–∏!",
                gridSize: 8,
                startPos: { x: 0, y: 0 },
                finishPos: { x: 6, y: 6 },
                startingStrength: 35,
                startingWeapon: 0,
                monsterStrength: 25,
                monsterDefense: 7,
                items: [
                    { x: 1, y: 2, type: 'strength', value: 10 },
                    { x: 3, y: 3, type: 'weapon', value: 4 },
                    { x: 5, y: 5, type: 'weapon', value: 4 },
                    { x: 6, y: 5, type: 'strength', value: 8 }
                ],
                obstacles: [
                    { x: 1, y: 1, type: 'rock' },
                    { x: 2, y: 3, type: 'tree' },
                    { x: 4, y: 4, type: 'rock' },
                    { x: 5, y: 6, type: 'tree' }
                ],
                allowLoops: true,
                hint: "üí° –ü–ª–∞–Ω—É–π—Ç–µ –∑–∞–∑–¥–∞–ª–µ–≥—ñ–¥—å! –ó–±–µ—Ä—ñ—Ç—å –í–°–Ü –±–æ–Ω—É—Å–∏ –∑–±—Ä–æ—ó.",
                difficulty: "–°–∫–ª–∞–¥–Ω–æ",
                optimalSteps: 14
            },
            10: {
                name: "üêâ –§—ñ–Ω–∞–ª—å–Ω–∞ –±–∏—Ç–≤–∞",
                description: "–û—Å—Ç–∞–Ω–Ω—ñ–π –≤–∏–∫–ª–∏–∫! –ü–µ—Ä–µ–º–æ–∂—ñ—Ç—å –¥—Ä–∞–∫–æ–Ω–∞!",
                gridSize: 8,
                startPos: { x: 0, y: 0 },
                finishPos: { x: 7, y: 7 },
                startingStrength: 40,
                startingWeapon: 0,
                monsterStrength: 28,
                monsterDefense: 8,
                items: [
                    { x: 1, y: 1, type: 'weapon', value: 3 },
                    { x: 2, y: 3, type: 'strength', value: 12 },
                    { x: 4, y: 2, type: 'weapon', value: 3 },
                    { x: 5, y: 5, type: 'strength', value: 10 },
                    { x: 6, y: 6, type: 'weapon', value: 3 }
                ],
                obstacles: [
                    { x: 1, y: 0, type: 'rock' },
                    { x: 2, y: 2, type: 'tree' },
                    { x: 3, y: 4, type: 'rock' },
                    { x: 4, y: 5, type: 'tree' },
                    { x: 6, y: 5, type: 'rock' },
                    { x: 7, y: 6, type: 'tree' }
                ],
                allowLoops: true,
                hint: "üí° –¶–µ —Ñ—ñ–Ω–∞–ª! –ó–±–µ—Ä—ñ—Ç—å –º—ñ–Ω—ñ–º—É–º 3 –∑–±—Ä–æ—ó. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ –≤—Å—ñ —Å–≤–æ—ó –∑–Ω–∞–Ω–Ω—è!",
                difficulty: "–î—É–∂–µ —Å–∫–ª–∞–¥–Ω–æ",
                optimalSteps: 16
            }
        };

        // ====================================
        // –°–¢–ê–ù –ì–†–ò
        // ====================================

        const GameState = {
            currentLevel: 1,
            heroPos: { x: 0, y: 0 },
            startPos: { x: 0, y: 0 },
            finishPos: { x: 3, y: 0 },
            items: [],
            obstacles: [],
            collectedItems: new Set(),
            currentStrength: 10,
            currentWeapon: 5,
            monsterStrength: 5,
            monsterDefense: 3,
            program: [],
            isRunning: false,
            executionStepCount: 0,
            completedLevels: new Set(),
            tutorialShown: localStorage.getItem('tutorialShown') === 'true',

            loadLevel(levelNum) {
                const level = LEVELS[levelNum];
                if (!level) return;

                this.currentLevel = levelNum;
                CONFIG.GRID_SIZE = level.gridSize;
                this.startPos = { ...level.startPos };
                this.finishPos = { ...level.finishPos };
                this.items = level.items.map(item => ({ ...item }));
                this.obstacles = level.obstacles ? level.obstacles.map(obs => ({ ...obs })) : [];
                this.currentStrength = level.startingStrength;
                this.currentWeapon = level.startingWeapon;
                this.monsterStrength = level.monsterStrength;
                this.monsterDefense = level.monsterDefense;
                
                // –ü–æ–∫–∞–∑–∞—Ç–∏/—Å—Ö–æ–≤–∞—Ç–∏ —Ü–∏–∫–ª–∏
                document.getElementById('loopsSection').classList.toggle('hidden', !level.allowLoops);
                
                // –û–Ω–æ–≤–∏—Ç–∏ UI —Ä—ñ–≤–Ω—è
                this.updateLevelUI(level);
                
                this.reset(true);
                
                // –ü–æ–∫–∞–∑–∞—Ç–∏ tutorial —Ç—ñ–ª—å–∫–∏ –Ω–∞ 1 —Ä—ñ–≤–Ω—ñ —Ç–∞ —è–∫—â–æ –Ω–µ –ø–æ–∫–∞–∑—É–≤–∞–ª–∏
                if (levelNum === 1 && !this.tutorialShown) {
                    setTimeout(() => {
                        document.getElementById('tutorialOverlay').classList.remove('hidden');
                        document.getElementById('tutorialOverlay').classList.add('flex');
                    }, 500);
                }
            },

            updateLevelUI(level) {
                const levelInfo = document.getElementById('levelInfo');
                levelInfo.innerHTML = `
                    <div class="font-bold text-base mb-1">${level.name}</div>
                    <div class="text-sm mb-2">${level.description}</div>
                    <div class="text-xs italic mb-2">${level.hint}</div>
                    <div class="flex flex-wrap gap-2 text-xs">
                        <span class="bg-red-100 text-red-700 px-2 py-1 rounded">üí™ –ú–æ–Ω—Å—Ç—Ä: ${this.monsterStrength}</span>
                        <span class="bg-gray-100 text-gray-700 px-2 py-1 rounded">üõ°Ô∏è –ó–∞—Ö–∏—Å—Ç: ${this.monsterDefense}</span>
                        <span class="bg-purple-100 text-purple-700 px-2 py-1 rounded">üìä ${level.difficulty}</span>
                        ${level.optimalSteps ? `<span class="bg-blue-100 text-blue-700 px-2 py-1 rounded">üéØ –û–ø—Ç–∏–º—É–º: ${level.optimalSteps} –∫—Ä–æ–∫—ñ–≤</span>` : ''}
                    </div>
                `;
                
                // –ü—Ä–æ–≥—Ä–µ—Å-–±–∞—Ä
                const progress = (this.currentLevel / CONFIG.TOTAL_LEVELS) * 100;
                document.getElementById('levelProgressBar').style.width = `${progress}%`;
                
                // –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤—ñ–≥–∞—Ü—ñ—ó
                document.getElementById('prevLevel').disabled = this.currentLevel === 1;
                document.getElementById('nextLevel').disabled = this.currentLevel === CONFIG.TOTAL_LEVELS || !this.completedLevels.has(this.currentLevel);
            },

            reset(resetRunning = true) {
                this.heroPos = { ...this.startPos };
                this.collectedItems.clear();
                const level = LEVELS[this.currentLevel];
                this.currentStrength = level.startingStrength;
                this.currentWeapon = level.startingWeapon;
                this.executionStepCount = 0;
                if (resetRunning) this.isRunning = false;
            },

            isObstacle(x, y) {
                return this.obstacles.some(obs => obs.x === x && obs.y === y);
            }
        };

        // ====================================
        // HAPTIC FEEDBACK
        // ====================================

        const HapticFeedback = {
            light() {
                if (CONFIG.HAPTIC_ENABLED) {
                    navigator.vibrate(10);
                }
            },
            
            medium() {
                if (CONFIG.HAPTIC_ENABLED) {
                    navigator.vibrate(20);
                }
            },
            
            success() {
                if (CONFIG.HAPTIC_ENABLED) {
                    navigator.vibrate([30, 50, 30]);
                }
            },
            
            error() {
                if (CONFIG.HAPTIC_ENABLED) {
                    navigator.vibrate([50, 100, 50]);
                }
            }
        };

        // ====================================
        // DND –°–¢–ê–ù (–ü–æ–∫—Ä–∞—â–µ–Ω–æ –¥–ª—è touch)
        // ====================================

        const DragState = {
            draggedItemData: null,
            dragPlaceholder: null,
            touchClone: null,
            currentTouchId: null,
            touchStartTime: 0,
            touchStartPos: { x: 0, y: 0 },
            isDragging: false,

            init() {
                this.dragPlaceholder = document.createElement('div');
                this.dragPlaceholder.className = 'drag-placeholder';
            },

            cleanup() {
                // –û—á–∏—â–µ–Ω–Ω—è touch clone
                if (this.touchClone) {
                    this.touchClone.remove();
                    this.touchClone = null;
                }
                
                // –û—á–∏—â–µ–Ω–Ω—è timeout'—ñ–≤
                document.querySelectorAll('[data-tap-timeout]').forEach(el => {
                    const timeout = el.dataset.tapTimeout;
                    if (timeout) {
                        clearTimeout(parseInt(timeout));
                        delete el.dataset.tapTimeout;
                    }
                });
                
                // –û—á–∏—â–µ–Ω–Ω—è —Å—Ç–∞–Ω—É
                this.currentTouchId = null;
                this.isDragging = false;
                this.draggedItemData = null;
                
                // –û—á–∏—â–µ–Ω–Ω—è –≤—ñ–∑—É–∞–ª—å–Ω–∏—Ö –µ—Ñ–µ–∫—Ç—ñ–≤
                document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                this.dragPlaceholder?.remove();
                
                // –í–∏–¥–∞–ª–µ–Ω–Ω—è –≥–ª–æ–±–∞–ª—å–Ω–∏—Ö listeners
                TouchHelpers.removeGlobalListeners();
            }
        };

        // ====================================
        // DOM –ö–ï–®
        // ====================================

        const DOM = {
            grid: null,
            programArea: null,
            position: null,
            strength: null,
            weapon: null,
            modal: null,
            modalContent: null,
            modalIcon: null,
            modalTitle: null,
            modalMessage: null,
            modalButtons: null,
            currentLevelSpan: null,
            stepCounter: null,
            stepCount: null,
            programCount: null,

            cache() {
                this.grid = document.querySelector('.grid');
                this.programArea = document.getElementById('programArea');
                this.weapon = document.getElementById('weapon');
                this.position = document.getElementById('position');
                this.strength = document.getElementById('strength');
                this.modal = document.getElementById('modal');
                this.modalContent = document.getElementById('modalContent');
                this.modalIcon = document.getElementById('modalIcon');
                this.modalTitle = document.getElementById('modalTitle');
                this.modalMessage = document.getElementById('modalMessage');
                this.modalButtons = document.getElementById('modalButtons');
                this.currentLevelSpan = document.getElementById('currentLevel');
                this.stepCounter = document.getElementById('stepCounter');
                this.stepCount = document.getElementById('stepCount');
                this.programCount = document.getElementById('programCount');
            }
        };

        // ====================================
        // –£–¢–ò–õ–Ü–¢–ò
        // ====================================

        const Utils = {
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },

            clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            },

            calculateTotalSteps(programArray, maxDepth = 3) {
                let total = 0;
                const calculate = (items, depth = 0) => {
                    if (depth > maxDepth) return 100;
                    for (const item of items) {
                        if (item.type === 'loop') {
                            total += item.count * calculate(item.commands, depth + 1);
                        } else {
                            total += 1;
                        }
                    }
                    return total;
                };
                calculate(programArray);
                return total;
            },

            isMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
        };

        // ====================================
        // –†–ï–ù–î–ï–†–ò–ù–ì –°–Ü–¢–ö–ò
        // ====================================

        const GridRenderer = {
            render() {
                DOM.grid.innerHTML = '';
                const size = CONFIG.GRID_SIZE;
                DOM.grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
                DOM.grid.style.gridTemplateRows = `repeat(${size}, 1fr)`;

                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const cell = this.createCell(x, y);
                        DOM.grid.appendChild(cell);
                    }
                }
                this.updateStats();
            },

            createCell(x, y) {
                const cell = document.createElement('div');
                cell.className = 'cell w-full h-full bg-gray-100 flex items-center justify-center transition-colors';
                cell.dataset.x = x;
                cell.dataset.y = y;

                const itemKey = `${x},${y}`;

                // –ì–µ—Ä–æ–π
                if (x === GameState.heroPos.x && y === GameState.heroPos.y) {
                    cell.classList.add('bg-blue-200');
                    cell.innerHTML = '<i class="fa-solid fa-user-shield text-blue-700"></i>';
                    return cell;
                }

                // –ú–æ–Ω—Å—Ç—Ä
                if (x === GameState.finishPos.x && y === GameState.finishPos.y) {
                    cell.classList.add('bg-red-300');
                    if (GameState.isRunning) {
                        cell.classList.add('pulse-hint');
                    }
                    cell.innerHTML = '<i class="fa-solid fa-dragon text-red-700"></i>';
                    return cell;
                }

                // –ü–µ—Ä–µ—à–∫–æ–¥–∏
                if (GameState.isObstacle(x, y)) {
                    const obstacle = GameState.obstacles.find(obs => obs.x === x && obs.y === y);
                    if (obstacle.type === 'tree') {
                        cell.classList.add('bg-green-600');
                        cell.innerHTML = '<i class="fa-solid fa-tree text-green-900"></i>';
                    } else if (obstacle.type === 'rock') {
                        cell.classList.add('bg-gray-400');
                        cell.innerHTML = '<i class="fa-solid fa-mountain text-gray-700"></i>';
                    }
                    return cell;
                }

                // –ü—Ä–µ–¥–º–µ—Ç–∏
                if (!GameState.collectedItems.has(itemKey)) {
                    const foundItem = GameState.items.find(item => item.x === x && item.y === y);
                    if (foundItem) {
                        if (foundItem.type === 'strength') {
                            cell.classList.add('bg-yellow-200');
                            cell.innerHTML = `<i class="fa-solid fa-bolt text-yellow-600"></i>`;
                        } else if (foundItem.type === 'weapon') {
                            cell.classList.add('bg-gray-300');
                            cell.innerHTML = `<i class="fa-solid fa-gavel text-gray-700"></i>`;
                        }
                    }
                }

                return cell;
            },

            updateStats() {
                DOM.weapon.textContent = GameState.currentWeapon;
                DOM.position.textContent = `(${GameState.heroPos.x}, ${GameState.heroPos.y})`;
                DOM.strength.textContent = GameState.currentStrength;
                DOM.currentLevelSpan.textContent = GameState.currentLevel;
                
                // –û–Ω–æ–≤–∏—Ç–∏ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –∫—Ä–æ–∫—ñ–≤
                const totalSteps = Utils.calculateTotalSteps(GameState.program);
                const level = LEVELS[GameState.currentLevel];
                DOM.stepCount.textContent = totalSteps;
                
                if (totalSteps > 0) {
                    DOM.stepCounter.classList.remove('hidden');
                    // –ü—ñ–¥—Å–≤—ñ—Ç–∫–∞ —è–∫—â–æ –±–ª–∏–∑—å–∫–æ –¥–æ –æ–ø—Ç–∏–º—É–º—É
                    if (level.optimalSteps && totalSteps <= level.optimalSteps + 2) {
                        DOM.stepCounter.classList.add('bg-green-50', 'border-green-400', 'text-green-700');
                        DOM.stepCounter.classList.remove('bg-purple-50', 'border-purple-400', 'text-purple-700');
                    } else {
                        DOM.stepCounter.classList.add('bg-purple-50', 'border-purple-400', 'text-purple-700');
                        DOM.stepCounter.classList.remove('bg-green-50', 'border-green-400', 'text-green-700');
                    }
                } else {
                    DOM.stepCounter.classList.add('hidden');
                }
            }
        };

        // ====================================
        // –í–ò–ö–û–ù–ê–ù–ù–Ø –ü–†–û–ì–†–ê–ú–ò
        // ====================================

        const ProgramExecutor = {
            async run() {
                if (GameState.isRunning) return;

                if (GameState.program.length === 0) {
                    ModalManager.show('ü§î –ü—Ä–æ–≥—Ä–∞–º–∞ –ø–æ—Ä–æ–∂–Ω—è', '–î–æ–¥–∞–π—Ç–µ –∫–æ–º–∞–Ω–¥–∏ –¥–æ –ø—Ä–æ–≥—Ä–∞–º–∏!\n\n–¢–æ—Ä–∫–Ω—ñ—Ç—å—Å—è –∫–æ–º–∞–Ω–¥ –∑–ª—ñ–≤–∞ –∞–±–æ –ø–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å —ó—Ö.', 'error');
                    HapticFeedback.error();
                    return;
                }

                const estimatedSteps = Utils.calculateTotalSteps(GameState.program);
                if (estimatedSteps > CONFIG.MAX_EXECUTION_STEPS) {
                    ModalManager.show('‚ö†Ô∏è –ó–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–æ', `–ü—Ä–æ–≥—Ä–∞–º–∞ –≤–∏–∫–æ–Ω–∞—î—Ç—å—Å—è –∑–∞ ${estimatedSteps} –∫—Ä–æ–∫—ñ–≤.\n\n–ú–∞–∫—Å–∏–º—É–º: ${CONFIG.MAX_EXECUTION_STEPS}. –°–ø—Ä–æ—Å—Ç—ñ—Ç—å –∫–æ–¥!`, 'error');
                    HapticFeedback.error();
                    return;
                }

                // –ü–ª–∞–≤–Ω–∏–π —Å–∫—Ä–æ–ª –¥–æ —Å—ñ—Ç–∫–∏
                DOM.grid.scrollIntoView({ behavior: 'smooth', block: 'center' });

                GameState.isRunning = true;
                ModalManager.hide();
                GameState.reset(false);
                GridRenderer.render();
                HapticFeedback.medium();

                try {
                    await this.execute(GameState.program);
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è:', error);
                    ModalManager.show('‚ùå –ü–æ–º–∏–ª–∫–∞', '–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—ñ –ø—Ä–æ–≥—Ä–∞–º–∏.', 'error');
                    HapticFeedback.error();
                } finally {
                    // –ì–∞—Ä–∞–Ω—Ç—É—î–º–æ —â–æ —Å—Ç–∞–Ω –∑–∞–≤–∂–¥–∏ —Å–∫–∏–¥–∞—î—Ç—å—Å—è
                    const wasRunning = GameState.isRunning;
                    GameState.isRunning = false;
                    this.checkWin(true, wasRunning);
                }
            },

            async execute(commandList) {
                try {
                    for (const item of commandList) {
                        if (!GameState.isRunning) return;

                        GameState.executionStepCount++;
                        if (GameState.executionStepCount > CONFIG.MAX_EXECUTION_STEPS) {
                            ModalManager.show('‚è±Ô∏è –¢–∞–π–º-–∞—É—Ç', '–ü—Ä–æ–≥—Ä–∞–º–∞ –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –∑–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–æ.\n\n–°–ø—Ä–æ—Å—Ç—ñ—Ç—å —Å–≤—ñ–π –∞–ª–≥–æ—Ä–∏—Ç–º!', 'error');
                            HapticFeedback.error();
                            GameState.isRunning = false;
                            return;
                        }

                        if (item.type === 'loop') {
                            for (let i = 0; i < item.count; i++) {
                                if (!GameState.isRunning) return;
                                await this.execute(item.commands);
                            }
                        } else {
                            if (GameState.currentStrength <= 0) {
                                ModalManager.show('üíÄ –ù–µ–º–∞—î —Å–∏–ª–∏', '–£ –≤–∞—Å –∑–∞–∫—ñ–Ω—á–∏–ª–∞—Å—è —Å–∏–ª–∞!\n\n–ó–±–∏—Ä–∞–π—Ç–µ –±–æ–Ω—É—Å–∏ –∞–±–æ —Å–∫–æ—Ä–æ—Ç—ñ—Ç—å —à–ª—è—Ö.', 'error');
                                HapticFeedback.error();
                                GameState.isRunning = false;
                                return;
                            }

                            await Utils.sleep(CONFIG.ANIMATION_DELAY);
                            this.executeCommand(item.command);
                            GridRenderer.render();
                            HapticFeedback.light();
                        }
                        
                        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø–µ—Ä–µ–º–æ–≥–∏ –ø—ñ—Å–ª—è –∫–æ–∂–Ω–æ–≥–æ –∫—Ä–æ–∫—É
                        if (this.checkWin()) {
                            return;
                        }
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –≤ execute:', error);
                    GameState.isRunning = false;
                    throw error;
                }
            },

            executeCommand(command) {
                const newPos = { ...GameState.heroPos };

                switch (command) {
                    case 'up': newPos.y = Math.max(0, GameState.heroPos.y - 1); break;
                    case 'down': newPos.y = Math.min(CONFIG.GRID_SIZE - 1, GameState.heroPos.y + 1); break;
                    case 'left': newPos.x = Math.max(0, GameState.heroPos.x - 1); break;
                    case 'right': newPos.x = Math.min(CONFIG.GRID_SIZE - 1, GameState.heroPos.x + 1); break;
                }

                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –ø–µ—Ä–µ—à–∫–æ–¥—É
                if (GameState.isObstacle(newPos.x, newPos.y)) {
                    return; // –ù–µ —Ä—É—Ö–∞—î–º–æ—Å—å —ñ –Ω–µ –≤–∏—Ç—Ä–∞—á–∞—î–º–æ —Å–∏–ª—É
                }

                GameState.heroPos = newPos;
                GameState.currentStrength--;

                // –ó–±—ñ—Ä –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
                const itemKey = `${GameState.heroPos.x},${GameState.heroPos.y}`;
                if (!GameState.collectedItems.has(itemKey)) {
                    const foundItem = GameState.items.find(item => 
                        item.x === GameState.heroPos.x && item.y === GameState.heroPos.y
                    );
                    if (foundItem) {
                        if (foundItem.type === 'strength') {
                            GameState.currentStrength += foundItem.value;
                        } else if (foundItem.type === 'weapon') {
                            GameState.currentWeapon += foundItem.value;
                        }
                        GameState.collectedItems.add(itemKey);
                        HapticFeedback.medium();
                    }
                }
            },

            checkWin(isFinalCheck = false, wasRunning = true) {
                if (GameState.heroPos.x === GameState.finishPos.x && 
                    GameState.heroPos.y === GameState.finishPos.y) {
                    
                    const hasEnoughStrength = GameState.currentStrength > GameState.monsterStrength;
                    const hasEnoughWeapon = GameState.currentWeapon >= GameState.monsterDefense;

                    if (hasEnoughStrength && hasEnoughWeapon) {
                        GameState.completedLevels.add(GameState.currentLevel);
                        HapticFeedback.success();
                        
                        // –ü–æ—Ä–∞—Ö—É–≤–∞—Ç–∏ –∑—ñ—Ä–∫–∏
                        const level = LEVELS[GameState.currentLevel];
                        const totalSteps = Utils.calculateTotalSteps(GameState.program);
                        let stars = '‚≠ê';
                        if (level.optimalSteps) {
                            if (totalSteps === level.optimalSteps) stars = '‚≠ê‚≠ê‚≠ê';
                            else if (totalSteps <= level.optimalSteps + 3) stars = '‚≠ê‚≠ê';
                        }
                        
                        if (GameState.currentLevel < CONFIG.TOTAL_LEVELS) {
                            ModalManager.show(
                                `üéâ –ü–µ—Ä–µ–º–æ–≥–∞! ${stars}`,
                                `–í–∏ –ø–µ—Ä–µ–º–æ–≥–ª–∏ –Ω–∞ —Ä—ñ–≤–Ω—ñ ${GameState.currentLevel}!\n\n–ö—Ä–æ–∫—ñ–≤: ${totalSteps}${level.optimalSteps ? `\n–û–ø—Ç–∏–º—É–º: ${level.optimalSteps}` : ''}\n\n–ì–æ—Ç–æ–≤—ñ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –≤–∏–∫–ª–∏–∫—É?`,
                                'success',
                                [
                                    {
                                        text: '‚ñ∂Ô∏è –î–∞–ª—ñ',
                                        class: 'bg-green-500 hover:bg-green-600',
                                        action: () => {
                                            LevelManager.loadNext();
                                            ModalManager.hide();
                                        }
                                    },
                                    {
                                        text: 'üîÑ –ü–æ–∫—Ä–∞—â–∏—Ç–∏',
                                        class: 'bg-blue-500 hover:bg-blue-600',
                                        action: () => {
                                            GameState.loadLevel(GameState.currentLevel);
                                            GridRenderer.render();
                                            ModalManager.hide();
                                        }
                                    }
                                ]
                            );
                        } else {
                            ModalManager.show(
                                'üèÜ –ü–ï–†–ï–ú–û–ì–ê!',
                                '–í—ñ—Ç–∞—î–º–æ! –í–∏ –ø—Ä–æ–π—à–ª–∏ –≤—Å—ñ —Ä—ñ–≤–Ω—ñ!\n\n–í–∏ —Å–ø—Ä–∞–≤–∂–Ω—ñ–π –º–∞–π—Å—Ç–µ—Ä –∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤ —Ç–∞ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è! üéä',
                                'success'
                            );
                        }
                    } else {
                        let errorMsg = '‚öîÔ∏è –ü—Ä–æ–≥—Ä–∞–ª–∏ –±—ñ–π!\n\n';
                        if (!hasEnoughStrength) {
                            errorMsg += `üíî –°–∏–ª–∞: ${GameState.currentStrength} (—Ç—Ä–µ–±–∞ > ${GameState.monsterStrength})\n`;
                        }
                        if (!hasEnoughWeapon) {
                            errorMsg += `üó°Ô∏è –ó–±—Ä–æ—è: ${GameState.currentWeapon} (—Ç—Ä–µ–±–∞ >= ${GameState.monsterDefense})`;
                        }
                        errorMsg += '\n\n–ó–±–µ—Ä—ñ—Ç—å –±—ñ–ª—å—à–µ —Ä–µ—Å—É—Ä—Å—ñ–≤!';
                        
                        ModalManager.show('üò¢ –ü–æ—Ä–∞–∑–∫–∞', errorMsg, 'error');
                        HapticFeedback.error();
                    }
                    GameState.isRunning = false;
                    return true;
                } else if (isFinalCheck && wasRunning) {
                    ModalManager.show('ü§î –•–º...', '–ü—Ä–æ–≥—Ä–∞–º–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å, –∞–ª–µ –≤–∏ –Ω–µ –¥—ñ—Å—Ç–∞–ª–∏—Å—è –º–æ–Ω—Å—Ç—Ä–∞.\n\n–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Å–≤—ñ–π –∞–ª–≥–æ—Ä–∏—Ç–º!', 'error');
                    HapticFeedback.error();
                    return false;
                }
                return false;
            }
        };

        // ====================================
        // –ú–û–î–ê–õ–¨–ù–ï –í–Ü–ö–ù–û
        // ====================================

        const ModalManager = {
            show(title, text, type, buttons = null) {
                // –ó–∞–ø–æ–±—ñ–≥–∞–Ω–Ω—è –º–Ω–æ–∂–∏–Ω–Ω–∏–º –≤–∏–∫–ª–∏–∫–∞–º
                if (!DOM.modal.classList.contains('hidden')) {
                    return;
                }

                DOM.modalTitle.textContent = title;
                DOM.modalMessage.textContent = text;

                DOM.modalIcon.innerHTML = '';
                DOM.modalIcon.className = 'w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4 text-4xl';

                if (type === 'success') {
                    DOM.modalIcon.classList.add('bg-green-100', 'text-green-600', 'level-complete');
                    DOM.modalIcon.innerHTML = '<i class="fa-solid fa-check"></i>';
                } else {
                    DOM.modalIcon.classList.add('bg-red-100', 'text-red-600');
                    DOM.modalIcon.innerHTML = '<i class="fa-solid fa-xmark"></i>';
                }

                // –ö–Ω–æ–ø–∫–∏
                DOM.modalButtons.innerHTML = '';
                if (buttons && Array.isArray(buttons)) {
                    buttons.forEach(btn => {
                        const button = document.createElement('button');
                        button.textContent = btn.text;
                        button.className = `haptic-light py-3 px-6 text-base font-semibold rounded-lg shadow-md transition-all text-white ${btn.class}`;
                        button.addEventListener('click', () => {
                            HapticFeedback.light();
                            btn.action();
                        });
                        DOM.modalButtons.appendChild(button);
                    });
                } else {
                    const defaultBtn = document.createElement('button');
                    defaultBtn.textContent = '–ó—Ä–æ–∑—É–º—ñ–ª–æ';
                    defaultBtn.className = `haptic-light py-3 px-8 text-base font-semibold rounded-lg shadow-md transition-all text-white ${
                        type === 'success' ? 'bg-green-500 hover:bg-green-600' : 'bg-red-500 hover:bg-red-600'
                    }`;
                    defaultBtn.addEventListener('click', () => {
                        HapticFeedback.light();
                        ModalManager.hide();
                    });
                    DOM.modalButtons.appendChild(defaultBtn);
                }

                DOM.modal.classList.remove('hidden');

                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ requestAnimationFrame –¥–ª—è –ø–ª–∞–≤–Ω–æ—ó –∞–Ω—ñ–º–∞—Ü—ñ—ó
                requestAnimationFrame(() => {
                    DOM.modalContent.classList.remove('scale-95', 'opacity-0');
                    DOM.modalContent.classList.add('scale-100', 'opacity-100');
                });
            },

            hide() {
                DOM.modalContent.classList.add('scale-95', 'opacity-0');
                DOM.modalContent.classList.remove('scale-100', 'opacity-100');

                setTimeout(() => {
                    DOM.modal.classList.add('hidden');
                }, 200);
            }
        };

        // ====================================
        // –ú–ï–ù–ï–î–ñ–ï–† –†–Ü–í–ù–Ü–í
        // ====================================

        const LevelManager = {
            loadNext() {
                if (GameState.currentLevel < CONFIG.TOTAL_LEVELS) {
                    GameState.program = [];
                    GameState.loadLevel(GameState.currentLevel + 1);
                    GridRenderer.render();
                    ProgramRenderer.render();
                    HapticFeedback.medium();
                }
            },

            loadPrev() {
                if (GameState.currentLevel > 1) {
                    GameState.program = [];
                    GameState.loadLevel(GameState.currentLevel - 1);
                    GridRenderer.render();
                    ProgramRenderer.render();
                    HapticFeedback.medium();
                }
            }
        };

        // ====================================
        // –†–ï–ù–î–ï–†–ò–ù–ì –ü–†–û–ì–†–ê–ú–ò
        // ====================================

        const ProgramRenderer = {
            eventHandlers: new WeakMap(),

            render() {
                DOM.programArea.innerHTML = '';
                this.renderContainer(DOM.programArea, GameState.program, '');
                
                // –û–Ω–æ–≤–∏—Ç–∏ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –±–ª–æ–∫—ñ–≤
                const blockCount = Utils.calculateTotalSteps(GameState.program);
                DOM.programCount.textContent = `${GameState.program.length} –±–ª–æ–∫—ñ–≤`;
                
                GridRenderer.updateStats();
            },

            renderContainer(container, items, pathPrefix) {
                if (items.length === 0 && container !== DOM.programArea) {
                    container.innerHTML = '<div class="text-center text-xs text-white/70 p-2">–ö–æ–º–∞–Ω–¥–∏ —Å—é–¥–∏</div>';
                }

                items.forEach((item, index) => {
                    const currentPath = pathPrefix ? `${pathPrefix},${index}` : `${index}`;
                    const blockEl = this.createBlock(item, currentPath);

                    if (index === 0) blockEl.classList.add('rounded-t-lg');
                    if (index === items.length - 1) blockEl.classList.add('rounded-b-lg');
                    if (index < items.length - 1) blockEl.classList.add('-mb-px');

                    blockEl.classList.add('fade-in');
                    container.appendChild(blockEl);
                });
            },

            createBlock(item, path) {
                const blockEl = document.createElement('div');
                blockEl.dataset.path = path;
                blockEl.setAttribute('draggable', 'true');
                blockEl.className = 'program-block p-2 md:p-3 shadow-md transition-transform duration-150';

                const commandIcons = {
                    'up': 'fa-arrow-up',
                    'down': 'fa-arrow-down',
                    'left': 'fa-arrow-left',
                    'right': 'fa-arrow-right'
                };
                const commandText = {
                    'up': '–í–≥–æ—Ä—É',
                    'down': '–í–Ω–∏–∑',
                    'left': '–õ—ñ–≤–æ—Ä—É—á',
                    'right': '–ü—Ä–∞–≤–æ—Ä—É—á'
                };

                if (item.type === 'loop') {
                    this.setupLoopBlock(blockEl, item, path);
                } else {
                    this.setupCommandBlock(blockEl, item, path, commandIcons, commandText);
                }

                this.attachDragHandlers(blockEl, path);
                return blockEl;
            },

            setupLoopBlock(blockEl, item, path) {
                blockEl.classList.add('bg-pink-500', 'text-white', 'p-3');

                const loopHeader = document.createElement('div');
                loopHeader.className = 'loop-header flex justify-between items-center mb-2';
                loopHeader.innerHTML = `
                    <span class="font-semibold flex items-center text-xs md:text-sm">
                        <i class="fa-solid fa-repeat mr-2"></i>
                        –ü–æ–≤—Ç–æ—Ä–∏—Ç–∏ 
                        <input type="number" class="loop-count w-12 text-center bg-white text-pink-500 font-bold rounded mx-1 md:mx-2 p-1" value="${item.count}" min="${CONFIG.MIN_LOOP_COUNT}" max="${CONFIG.MAX_LOOP_COUNT}">
                        —Ä–∞–∑—ñ–≤
                    </span>
                    <button class="remove-btn haptic-light w-7 h-7 bg-white/20 hover:bg-white/40 rounded-full flex items-center justify-center transition-colors">
                        <i class="fa-solid fa-xmark text-white"></i>
                    </button>
                `;

                const countInput = loopHeader.querySelector('.loop-count');
                const removeBtn = loopHeader.querySelector('.remove-btn');

                const countHandler = (e) => {
                    ProgramDataManager.updateLoopCount(path, e.target.value);
                    HapticFeedback.light();
                };
                const removeHandler = () => {
                    ProgramDataManager.removeItemByPath(path);
                    this.render();
                    HapticFeedback.light();
                };

                countInput.addEventListener('change', countHandler);
                countInput.addEventListener('input', countHandler);
                removeBtn.addEventListener('click', removeHandler);

                this.eventHandlers.set(countInput, countHandler);
                this.eventHandlers.set(removeBtn, removeHandler);

                const loopBody = document.createElement('div');
                loopBody.className = 'loop-body bg-black/10 p-2 rounded-lg min-h-[50px] border-2 border-dashed border-white/30';
                loopBody.dataset.path = path;

                loopBody.addEventListener('dragover', DragHandlers.handleDragOverContainer);
                loopBody.addEventListener('drop', DragHandlers.handleDropOnContainer);

                this.renderContainer(loopBody, item.commands, path);

                blockEl.appendChild(loopHeader);
                blockEl.appendChild(loopBody);
            },

            setupCommandBlock(blockEl, item, path, commandIcons, commandText) {
                blockEl.classList.add('bg-indigo-500', 'text-white', 'flex', 'justify-between', 'items-center', 'cursor-move', 'haptic-light');
                blockEl.innerHTML = `
                    <span class="font-semibold flex items-center text-xs md:text-sm">
                        <i class="fa-solid ${commandIcons[item.command]} mr-2 md:mr-3 w-4 md:w-5 text-center"></i>
                        ${commandText[item.command]}
                    </span>
                    <button class="remove-btn haptic-light w-7 h-7 bg-white/20 hover:bg-white/40 rounded-full flex items-center justify-center transition-colors">
                        <i class="fa-solid fa-xmark text-white"></i>
                    </button>
                `;

                const removeBtn = blockEl.querySelector('.remove-btn');
                const removeHandler = () => {
                    ProgramDataManager.removeItemByPath(path);
                    this.render();
                    HapticFeedback.light();
                };
                removeBtn.addEventListener('click', removeHandler);
                this.eventHandlers.set(removeBtn, removeHandler);
            },

            attachDragHandlers(blockEl, path) {
                blockEl.addEventListener('dragstart', (e) => DragHandlers.handleDragStartBlock(e, path));
                blockEl.addEventListener('touchstart', TouchHandlers.handleTouchStartBlock, { passive: false });
                blockEl.addEventListener('dragenter', (e) => e.stopPropagation());
            }
        };

        // ====================================
        // –£–ü–†–ê–í–õ–Ü–ù–ù–Ø –î–ê–ù–ò–ú–ò
        // ====================================

        const ProgramDataManager = {
            findDropTarget(pathStr) {
                if (!pathStr) return GameState.program;

                const path = pathStr.split(',').map(Number);
                let target = GameState.program;

                for (const index of path) {
                    if (target[index] && target[index].commands) {
                        target = target[index].commands;
                    } else {
                        return null;
                    }
                }
                return target;
            },

            findItemByPath(pathStr) {
                const path = pathStr.split(',').map(Number);
                let currentLevel = GameState.program;

                for (let i = 0; i < path.length - 1; i++) {
                    currentLevel = currentLevel[path[i]].commands;
                }
                return currentLevel[path[path.length - 1]];
            },

            removeItemByPath(pathStr) {
                const path = pathStr.split(',').map(Number);
                let parentArray = GameState.program;

                if (path.length > 1) {
                    let parent = GameState.program[path[0]];
                    for (let i = 1; i < path.length - 1; i++) {
                        parent = parent.commands[path[i]];
                    }
                    parentArray = parent.commands;
                }

                const indexToRemove = path[path.length - 1];
                return parentArray.splice(indexToRemove, 1)[0];
            },

            updateLoopCount(pathStr, value) {
                const count = parseInt(value) || CONFIG.MIN_LOOP_COUNT;
                const item = this.findItemByPath(pathStr);
                item.count = Utils.clamp(count, CONFIG.MIN_LOOP_COUNT, CONFIG.MAX_LOOP_COUNT);

                const input = document.querySelector(`[data-path="${pathStr}"] .loop-count`);
                if (input) input.value = item.count;
                
                GridRenderer.updateStats();
            }
        };

        // ====================================
        // –û–ë–†–û–ë–ù–ò–ö–ò DND
        // ====================================

        const DragHandlers = {
            handleDragStartBlock(e, path) {
                e.stopPropagation();
                DragState.draggedItemData = {
                    isNew: false,
                    path: path,
                    item: ProgramDataManager.findItemByPath(path)
                };
                e.dataTransfer.effectAllowed = 'move';
                setTimeout(() => e.target.classList.add('dragging'), 0);
                HapticFeedback.light();
            },

            handleDragOverContainer(e) {
                e.preventDefault();
                e.stopPropagation();
                const container = e.currentTarget;

                const afterElement = DragHelpers.getDragAfterElement(container, e.clientX, e.clientY);

                if (afterElement) {
                    container.insertBefore(DragState.dragPlaceholder, afterElement);
                } else {
                    container.appendChild(DragState.dragPlaceholder);
                }
            },

            handleDropOnContainer(e) {
                e.preventDefault();
                e.stopPropagation();

                if (!DragState.draggedItemData) return;

                DragState.draggedItemData.dropHandled = true;

                const container = e.currentTarget;
                const targetPath = container.dataset.path || '';

                let itemToInsert;

                if (DragState.draggedItemData.isNew) {
                    if (DragState.draggedItemData.command === 'loop') {
                        itemToInsert = { type: 'loop', count: 2, commands: [] };
                    } else {
                        itemToInsert = { type: 'command', command: DragState.draggedItemData.command };
                    }
                } else {
                    itemToInsert = ProgramDataManager.removeItemByPath(DragState.draggedItemData.path);
                }

                if (!itemToInsert) return;

                const children = Array.from(container.children);
                let insertIndex = children.indexOf(DragState.dragPlaceholder);
                if (insertIndex === -1) insertIndex = children.length;

                const targetArray = ProgramDataManager.findDropTarget(targetPath);
                if (targetArray) {
                    targetArray.splice(insertIndex, 0, itemToInsert);
                }

                ProgramRenderer.render();
                HapticFeedback.medium();
            },

            handleDragEnd(e) {
                if (DragState.draggedItemData && !DragState.draggedItemData.isNew && !DragState.draggedItemData.dropHandled) {
                    ProgramDataManager.removeItemByPath(DragState.draggedItemData.path);
                    ProgramRenderer.render();
                }

                DragState.cleanup();
            }
        };

        // ====================================
        // TOUCH –û–ë–†–û–ë–ù–ò–ö–ò (–ü–æ–∫—Ä–∞—â–µ–Ω–æ)
        // ====================================

        const TouchHandlers = {
handleTouchStartPalette(e) {
                // –ù–µ –±–ª–æ–∫—É—î–º–æ –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ —Ç–∞–ø—É
                const touch = e.changedTouches[0];
                
                if (DragState.currentTouchId !== null) return;

                const block = e.currentTarget;
                
                DragState.touchStartTime = Date.now();
                DragState.touchStartPos = { x: touch.clientX, y: touch.clientY };
                DragState.currentTouchId = touch.identifier;

                // –û—á–∏—Å—Ç–∏—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π —Ç–∞–π–º–∞—É—Ç —è–∫—â–æ —î
                if (block.dataset.tapTimeout) {
                    clearTimeout(parseInt(block.dataset.tapTimeout));
                    delete block.dataset.tapTimeout;
                }

                // –ö–æ—Ä–æ—Ç–∫–∏–π —Ç–∞–ø = —à–≤–∏–¥–∫–µ –¥–æ–¥–∞–≤–∞–Ω–Ω—è
                const tapTimeout = setTimeout(() => {
                    if (!DragState.isDragging && DragState.currentTouchId === touch.identifier) {
                        // –ü–µ—Ä–µ—Ç–≤–æ—Ä—é—î–º–æ –≤ drag
                        e.preventDefault();
                        DragState.isDragging = true;
                        DragState.draggedItemData = {
                            isNew: true,
                            command: block.dataset.command
                        };

                        TouchHelpers.createTouchClone(block, touch);
                        TouchHelpers.addGlobalListeners();
                        HapticFeedback.light();
                    }
                }, CONFIG.TOUCH_HOLD_DELAY);

                block.dataset.tapTimeout = tapTimeout;
            },

            handleTouchStartBlock(e) {
                e.preventDefault();
                e.stopPropagation();
                if (DragState.currentTouchId !== null) return;

                const touch = e.changedTouches[0];
                DragState.currentTouchId = touch.identifier;
                DragState.touchStartTime = Date.now();
                DragState.isDragging = true;

                const blockEl = e.currentTarget;
                const path = blockEl.dataset.path;

                DragState.draggedItemData = {
                    isNew: false,
                    path: path,
                    item: ProgramDataManager.findItemByPath(path)
                };

                TouchHelpers.createTouchClone(blockEl, touch);
                blockEl.classList.add('dragging');
                TouchHelpers.addGlobalListeners();
                HapticFeedback.light();
            },

            handleTouchMove(e) {
                if (DragState.currentTouchId === null) return;
                
                if (!DragState.isDragging) {
                    const touch = Array.from(e.changedTouches).find(t => t.identifier === DragState.currentTouchId);
                    if (touch) {
                        const distance = Math.hypot(
                            touch.clientX - DragState.touchStartPos.x,
                            touch.clientY - DragState.touchStartPos.y
                        );
                        
                        // –Ø–∫—â–æ —Ä—É—Ö > 10px, —Å–∫–∞—Å–æ–≤—É—î–º–æ tap
                        if (distance > 10) {
                            DragState.isDragging = true;
                        }
                    }
                }
                
                if (!DragState.isDragging) return;
                
                e.preventDefault();

                const touch = Array.from(e.changedTouches).find(t => t.identifier === DragState.currentTouchId);
                if (!touch) return;

                TouchHelpers.updateClonePos(touch);

                const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
                if (!elementUnder) return;

                const container = elementUnder.closest('.program-area, .loop-body');
                if (container) {
                    const afterElement = DragHelpers.getDragAfterElement(container, touch.clientX, touch.clientY);
                    if (afterElement) {
                        container.insertBefore(DragState.dragPlaceholder, afterElement);
                    } else {
                        container.appendChild(DragState.dragPlaceholder);
                    }
                } else {
                    DragState.dragPlaceholder.remove();
                }
            },

            handleTouchEnd(e) {
                if (DragState.currentTouchId === null) return;
                const touch = Array.from(e.changedTouches).find(t => t.identifier === DragState.currentTouchId);
                if (!touch) return;

                const holdDuration = Date.now() - DragState.touchStartTime;
                
                // –ö–æ—Ä–æ—Ç–∫–∏–π —Ç–∞–ø –±–µ–∑ —Ä—É—Ö—É = —à–≤–∏–¥–∫–µ –¥–æ–¥–∞–≤–∞–Ω–Ω—è
                if (!DragState.isDragging && holdDuration < CONFIG.TOUCH_HOLD_DELAY) {
                    if (DragState.draggedItemData && DragState.draggedItemData.isNew) {
                        const command = DragState.draggedItemData.command;
                        let newItem;

                        if (command === 'loop') {
                            newItem = { type: 'loop', count: 2, commands: [] };
                        } else {
                            newItem = { type: 'command', command: command };
                        }

                        GameState.program.push(newItem);
                        ProgramRenderer.render();
                        HapticFeedback.medium();
                    }
                    DragState.cleanup();
                    return;
                }

                // –Ü–Ω–∞–∫—à–µ - –∑–≤–∏—á–∞–π–Ω–∏–π drag & drop
                const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
                let dropTarget = null;
                if (elementUnder) {
                    dropTarget = elementUnder.closest('.program-area, .loop-body');
                }

                if (dropTarget && DragState.draggedItemData) {
                    DragState.draggedItemData.dropHandled = true;
                    const targetPath = dropTarget.dataset.path || '';
                    let itemToInsert;

                    if (DragState.draggedItemData.isNew) {
                        if (DragState.draggedItemData.command === 'loop') {
                            itemToInsert = { type: 'loop', count: 2, commands: [] };
                        } else {
                            itemToInsert = { type: 'command', command: DragState.draggedItemData.command };
                        }
                    } else {
                        const newPath = dropTarget.dataset.path;
                        if (newPath && newPath.startsWith(DragState.draggedItemData.path)) {
                            // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –≤–∫–ª–∞–¥–µ–Ω–Ω—è –≤ —Å–µ–±–µ
                        } else {
                            itemToInsert = ProgramDataManager.removeItemByPath(DragState.draggedItemData.path);
                        }
                    }

                    if (itemToInsert) {
                        const children = Array.from(dropTarget.children);
                        let insertIndex = children.indexOf(DragState.dragPlaceholder);
                        if (insertIndex === -1) insertIndex = children.length;

                        const targetArray = ProgramDataManager.findDropTarget(targetPath);
                        if (targetArray) {
                            targetArray.splice(insertIndex, 0, itemToInsert);
                        }
                    }
                    HapticFeedback.medium();
                } else if (DragState.draggedItemData && !DragState.draggedItemData.isNew) {
                    ProgramDataManager.removeItemByPath(DragState.draggedItemData.path);
                    HapticFeedback.light();
                }

                ProgramRenderer.render();
                DragState.cleanup();
            }
        };

        // ====================================
        // –î–û–ü–û–ú–Ü–ñ–ù–Ü –§–£–ù–ö–¶–Ü–á
        // ====================================

        const DragHelpers = {
            getDragAfterElement(container, clientX, clientY) {
                const draggableElements = [...container.children].filter(child =>
                    child.classList.contains('program-block') &&
                    !child.classList.contains('dragging')
                );

                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = clientY - box.top - box.height / 2;

                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
        };

        const TouchHelpers = {
            createTouchClone(originalBlock, touch) {
                DragState.touchClone = originalBlock.cloneNode(true);
                DragState.touchClone.classList.remove('dragging');
                DragState.touchClone.style.position = 'fixed';
                DragState.touchClone.style.zIndex = '1000';
                DragState.touchClone.style.pointerEvents = 'none';
                DragState.touchClone.style.width = `${originalBlock.offsetWidth}px`;
                DragState.touchClone.style.transition = 'none';
                DragState.touchClone.style.opacity = '0.8';
                DragState.touchClone.style.transform = 'scale(1.05)';
                DragState.touchClone.style.left = '0';
                DragState.touchClone.style.top = '0';
                document.body.appendChild(DragState.touchClone);
                this.updateClonePos(touch);
            },

            updateClonePos(touch) {
                if (!DragState.touchClone) return;
                const x = touch.clientX - DragState.touchClone.offsetWidth / 2;
                const y = touch.clientY - DragState.touchClone.offsetHeight / 2;
                DragState.touchClone.style.transform = `translate3d(${x}px, ${y}px, 0) scale(1.05)`;
            },

            addGlobalListeners() {
                document.addEventListener('touchmove', TouchHandlers.handleTouchMove, { passive: false });
                document.addEventListener('touchend', TouchHandlers.handleTouchEnd, { passive: false });
                document.addEventListener('touchcancel', TouchHandlers.handleTouchEnd, { passive: false });
            },

            removeGlobalListeners() {
                document.removeEventListener('touchmove', TouchHandlers.handleTouchMove);
                document.removeEventListener('touchend', TouchHandlers.handleTouchEnd);
                document.removeEventListener('touchcancel', TouchHandlers.handleTouchEnd);
            }
        };

        // ====================================
        // –ü–ê–õ–Ü–¢–†–ê
        // ====================================

        const PaletteManager = {
            setup() {
                document.querySelectorAll('.block[draggable="true"]').forEach(block => {
                    this.applyStyles(block);

                    block.addEventListener('dragstart', (e) => {
                        DragState.draggedItemData = {
                            isNew: true,
                            command: block.dataset.command
                        };
                        e.dataTransfer.effectAllowed = 'copy';
                        HapticFeedback.light();
                    });

                    // –®–≤–∏–¥–∫–µ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –∫–ª—ñ–∫–æ–º (–¥–ª—è –ü–ö)
                    block.addEventListener('click', () => {
                        if (GameState.isRunning) return;

                        const command = block.dataset.command;
                        let newItem;

                        if (command === 'loop') {
                            newItem = { type: 'loop', count: 2, commands: [] };
                        } else {
                            newItem = { type: 'command', command: command };
                        }

                        GameState.program.push(newItem);
                        ProgramRenderer.render();
                        HapticFeedback.medium();
                    });

                    block.addEventListener('touchstart', TouchHandlers.handleTouchStartPalette, { passive: true });
                });
            },

            applyStyles(block) {
                const baseStyles = 'flex items-center justify-center p-2 md:p-3 rounded-lg cursor-pointer user-select-none transition-all duration-200 font-semibold text-white text-xs md:text-sm shadow-md hover:shadow-lg hover:scale-105 active:scale-95';
                const styles = baseStyles.split(' ').filter(style => style.trim() !== '');
                
                if (block.classList.contains('loop')) {
                    block.classList.add(...styles, 'bg-pink-500', 'hover:bg-pink-600');
                } else {
                    block.classList.add(...styles, 'bg-indigo-500', 'hover:bg-indigo-600');
                }
            }
        };

        // ====================================
        // –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø
        // ====================================

        document.addEventListener('DOMContentLoaded', () => {
            try {
                DOM.cache();
                DragState.init();
                
                GameState.loadLevel(1);
                GridRenderer.render();
                PaletteManager.setup();

                DOM.programArea.addEventListener('dragover', DragHandlers.handleDragOverContainer);
                DOM.programArea.addEventListener('drop', DragHandlers.handleDropOnContainer);

                document.body.addEventListener('dragover', (e) => e.preventDefault());
                document.body.addEventListener('dragend', DragHandlers.handleDragEnd);

                // –ö–Ω–æ–ø–∫–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è
                document.querySelector('.run-btn').addEventListener('click', () => {
                    try {
                        ProgramExecutor.run();
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–ø—É—Å–∫—É –ø—Ä–æ–≥—Ä–∞–º–∏:', error);
                        ModalManager.show('‚ùå –ü–æ–º–∏–ª–∫–∞', '–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É –ø—Ä–æ–≥—Ä–∞–º–∏.', 'error');
                    }
                });
                
                document.querySelector('.reset-btn').addEventListener('click', () => {
                    try {
                        GameState.reset(true);
                        GridRenderer.render();
                        ModalManager.hide();
                        HapticFeedback.light();
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ —Å–∫–∏–¥–∞–Ω–Ω—è:', error);
                    }
                });
                
                document.querySelector('.clear-btn').addEventListener('click', () => {
                    try {
                        if (GameState.program.length > 0) {
                            GameState.program = [];
                            ProgramRenderer.render();
                            HapticFeedback.light();
                        }
                        ModalManager.hide();
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ –æ—á–∏—â–µ–Ω–Ω—è:', error);
                    }
                });

                // –ù–∞–≤—ñ–≥–∞—Ü—ñ—è —Ä—ñ–≤–Ω—ñ–≤
                document.getElementById('prevLevel').addEventListener('click', () => {
                    try {
                        LevelManager.loadPrev();
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ —Ä—ñ–≤–Ω—è:', error);
                    }
                });
                
                document.getElementById('nextLevel').addEventListener('click', () => {
                    try {
                        LevelManager.loadNext();
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è:', error);
                    }
                });

                // Tutorial
                document.getElementById('closeTutorial').addEventListener('click', () => {
                    try {
                        document.getElementById('tutorialOverlay').classList.add('hidden');
                        document.getElementById('tutorialOverlay').classList.remove('flex');
                        GameState.tutorialShown = true;
                        localStorage.setItem('tutorialShown', 'true');
                        HapticFeedback.light();
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–∫—Ä–∏—Ç—Ç—è tutorial:', error);
                    }
                });

                document.getElementById('showTutorial').addEventListener('click', () => {
                    try {
                        document.getElementById('tutorialOverlay').classList.remove('hidden');
                        document.getElementById('tutorialOverlay').classList.add('flex');
                        HapticFeedback.light();
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ –ø–æ–∫–∞–∑—É tutorial:', error);
                    }
                });

                // –ó–∞–ø–æ–±—ñ–≥–∞–Ω–Ω—è –≤–∏–ø–∞–¥–∫–æ–≤–æ–º—É zoom –Ω–∞ iOS
                document.addEventListener('gesturestart', (e) => e.preventDefault());
                
                // –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ—Å—Ç—å –¥–æ –∑–º—ñ–Ω–∏ –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        try {
                            GridRenderer.render();
                        } catch (error) {
                            console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–º—ñ–Ω—ñ –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó:', error);
                        }
                    }, 300);
                });

                console.log('üéÆ –ö–æ–¥–µ–≥–æ—Ä–æ—à–∫–æ –∑–∞–ø—É—â–µ–Ω–æ!', Utils.isMobile() ? 'üì± –ú–æ–±—ñ–ª—å–Ω–∏–π —Ä–µ–∂–∏–º' : 'üñ•Ô∏è –î–µ—Å–∫—Ç–æ–ø —Ä–µ–∂–∏–º');
            } catch (error) {
                console.error('–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó:', error);
                alert('–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É.');
            }
        });
    </script>
</body>
</html>
